<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./../css/posicionamiento.css">
    <title>Posicionamiento</title>
</head>

<body>
    <nav>
        <h2>Ejemplo de fixed</h2>
    </nav>

    <h1>Posicionamiento: </h1>
    <p>Dentro del tipo de display se puede posicionar un elemento hijo dentro de un elemento padre aquí algunos
        elementos:</p>
    <div>
        <ul>
            <li><b>Relative</b></li>
            <p>El elemento es posicionado de acuerdo al flujo normal del documento, y luego es desplazado con relación a
                sí mismo, con base en los valores de <b>top</b>, <b>right</b>, <b>bottom</b>, and <b>left</b>. <br> El
                desplazamiento no afecta la
                posición de ningún otro elemento; por lo que, el espacio que se le da al elemento en el esquema de la
                página es el mismo como si la posición fuera static. Este valor crea un nuevo contexto de apilamiento,
                donde el valor de z-index no es auto. El efecto que tiene relative sobre los elementos table-*-group,
                table-row, table-column, table-cell, y table-caption no está definido.
            </p>
            <p>El siguiente cuadro rojo tiene una posición relative:</p>
            <div class="container tomato">

            </div>

            <li><b>Absolute</b></li>
            <p>
                El elemento es removido del flujo normal del documento, sin crearse espacio alguno para el elemento en
                el esquema de la página. Es posicionado relativo a su ancestro posicionado más cercano, si lo hay; de lo
                contrario, se ubica relativo al bloque contenedor (en-US) inicial. Su posición final está determinada
                por los valores de top, right, bottom, y left.

                Este valor crea un nuevo contexto de apilamiento cuando el valor de z-index no es auto. Elementos
                absolutamente posicionados pueden tener margen, y no colapsan con ningún otro margen.
            </p>
            <p>Si agrgamos un elemento color verde y lo convertimos en position absolute y le damos un left 50px y top
                100px se vería así:</p>
            <div class="container tomato">
                <div class="item green">

                </div>
            </div>

    </div>

    <li><b>Fixed</b></li>
    <p>
        El elemento es removido del flujo normal del documento, sin crearse espacio alguno para el elemento en
        el esquema de la página. Es posicionado con relación al bloque contenedor (en-US) inicial establecido
        por el viewport, excepto cuando uno de sus ancestros tiene una propiedad transform, perspective, o
        filter establecida en algo que no sea none (ver CSS Transforms Spec), en cuyo caso ese ancestro se
        comporta como el bloque contenedor. (Notar que hay inconsistencias del navegador con perspective y
        filter contribuyendo a la formación del bloque contenedor.) Su posición final es determinada por los
        valores de top, right, bottom, y left.

        Estos valores siempre crean un nuevo contexto de apilamiento. En documentos impresos, el elemento se
        coloca en la misma posición en cada página.
    </p>
    <p><b>Por ejemplo:</b></p>


    <li><b>Sticky</b></li>
    <p>
        El elemento es posicionado de acuerdo al flujo normal del documento, y luego es desplazado con relación a su
        ancestro que se desplace más cercano y su bloque contenedor (en-US) (ancestro en nivel de bloque más cercano)
        incluyendo elementos relacionados a tablas, basados en los valores de top, right, bottom, y left. El
        desplazamiento no afecta la posición de ningún otro elmento.

        Estos valores siempre crean un nuevo contexto de apilamiento. Nótese que un elemento sticky se "adhiere" a su
        ancestro más cercano que tiene un "mecanismo de desplazamiento" (creado cuando el overflow es hidden, scroll,
        auto, o bien overlay), aún si ese ancestro no es el ancestro con desplazamiento más cercano. Esto inhibe
        efectivamente el comportamiento "sticky" (ver el Github issue en W3C CSSWG).
    </p>
    <p>Por ejemplo:</p>
    <ul>
        <h3> Vengadores Originales </h3>
        <li>Hulk</li>
        <li>Hawkeye</li>
        <li>Black Widow</li>
        <li>Iron Man</li>
        <li>Capitan América</li>
        <li>Thor</li>
    </ul>

    <ul>
        <h3>Vengadores nuevos</h3>
        <li>Antman</li>
        <li>Wanda</li>
        <li>Dr Strange</li>
        <li>Black Panther</li>
        <li>Capitana Marvel</li>
        <li>Wasp</li>
        <li>Visión</li>
        <li>Spiderman</li>
    </ul>

    <ol>
        <h3>Top de villanos</h3>
    </ol>

    <li><b>Static</b></li>
    <p>
        El elemento es posicionado de acuerdo al flujo normal del documento. Las propiedades top, right, bottom, left, and z-index no tienen efecto. Este es el valor por defecto.
    </p>

    <li><b>Initial</b></li>
    <li><b>Inhertial</b></li>
    </ul>
    </div>

    <h2>Este es un ejemplo de posicionamiento:</h2>
    <div class="container">
        <div class="item"></div>
    </div>
</body>

</html>